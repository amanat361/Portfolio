import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'

export const article = {
  author: 'Sam Amanat',
  date: '2025-03-09',
  title: 'The Side Project I'm Building to End My File-Request Nightmares',
  description: 'A super-simple tool to request and receive files without the hassle of endless email threads.',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

function Note({ children }) {
  return (
    <div className="my-8 rounded-lg bg-blue-50 p-6 dark:bg-blue-900/20">
      <div className="flex">
        <div className="flex-shrink-0">
          {/* Optional icon */}
          <svg className="h-5 w-5 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
          </svg>
        </div>
        <div className="ml-3">
          <div className="text-sm text-blue-800 dark:text-blue-200">{children}</div>
        </div>
      </div>
    </div>
  )
}

function Callout({ title, children }) {
  return (
    <div className="my-8 rounded-lg border border-gray-200 bg-gray-50 p-6 dark:border-gray-800 dark:bg-gray-900/50">
      {title && (
        <h3 className="mb-4 text-base font-medium text-gray-900 dark:text-gray-100">
          {title}
        </h3>
      )}
      <div className="text-gray-800 dark:text-gray-200">
        {children}
      </div>
    </div>
  )
}

So here's the thing about client work that nobody warns you about: the most frustrating part isn't the actual work—it's getting the materials you need to even start the work.

I can't tell you how many hours of my life have disappeared into the void of "Hey, just following up on that logo file" emails. Or how many projects have stalled because I'm waiting on a signed contract that's sitting forgotten in someone's inbox.

Last month, I hit my breaking point. I was juggling four client projects, and literally half my workday was spent writing variations of "Just checking if you got my email about..." messages. Not billable. Not productive. Just... chasing.

That night, I started sketching out a solution. What if there was a tool that made requesting files as simple as typing what you need, generating a link, and letting technology handle the rest?

Two weeks of late-night coding sessions later, **PleaseSendMeThis.com** was born.

<Note>
  This article documents my entire thought process, research, and development plan for this project. It's comprehensive by design—I want this to serve as both an introduction and a complete reference for anyone interested in the concept or implementation.
</Note>

## The Concept: File Requests Without the Friction

Before diving into the technical details, let me explain the core idea. I want the entire experience to feel like this:

1. I type: "Send me your logo in vector format and the signed contract"
2. The system instantly creates a form with those exact fields
3. I share a link with my client
4. They click, upload, done
5. I get notified, they get thanked, and we both move on with our lives

No accounts. No downloads. No friction.

To verify I wasn't reinventing the wheel, I tried every file request tool I could find. They all fell short in the same ways:
- Too much setup time (building forms field-by-field)
- Required clients to create accounts or download apps
- Lacked automated follow-ups
- Too complex for what should be a simple task

So I decided to build exactly what I needed. Here's the formal overview from my project plan:

<Callout title="From the Project Plan: Overview">
A lightweight web tool for quickly requesting files and information from clients without any hassle. The user (requester) simply types a natural-language request (e.g., "Send me the signed contract and invoice"), and the system generates a shareable link. The client (recipient) clicks the link to find an instant form and upload the requested files or input information, all without needing to sign up. This tool is designed for minimal friction on both sides, saving time and eliminating the back-and-forth of chasing down files.
</Callout>

## Core Features (or How It Actually Works)

Let me walk through the key components that make this system special, alternating between my personal take and the formal specs.

### AI-Generated Request Forms: Type Once, Done

The magical part is how you create requests. No form builder. No field configuration. Just type what you need in plain English:

```
"Please send me your updated logo in SVG format, your brand color hex codes, and a brief description of what you want highlighted on the homepage."
```

The AI then parses this into an appropriate form with:
- A file upload field for the SVG logo
- A text input field for hex codes
- A text area for the homepage description

This is genuinely the feature I'm most excited about. It cuts request creation time from minutes to seconds.

<Callout title="From the Project Plan: AI Form Generation">
Integrate an NLP/AI service to parse the user's natural language request into structured form fields. This could be done via an API call to a service like OpenAI GPT or a locally hosted model. The AI will identify entities in the request text (e.g., it sees terms like "signed contract" likely means a file upload field, or "updated mailing address" means a text field). The result is a draft form configuration (field labels, types). The user can be shown a preview of the generated form and allowed to tweak it if necessary before finalizing the request. This AI component should be lightweight and fast to keep the experience quick.
</Callout>

I've been testing this with GPT-4 and it's surprisingly accurate at determining the right field types. For example, it correctly identifies:
- "Send me your headshot" → Image upload field
- "What's your availability next week?" → Text field or potentially date picker
- "Share your company background" → Text area for longer content

And when it's not perfect, you can quickly adjust the generated form before sending it.

### Shareable Links: The Magic Delivery System

Every request generates a unique link that works like a mini-portal for your client:

```
pleasesendmethis.com/r/8f7h3j2k1l
```

When they click it, they see exactly what you've requested, clearly labeled and ready for upload. No accounts. No downloads. Just a clean, simple interface that works on any device.

<Callout title="From the Project Plan: Unique Shareable Link">
Each request generates a unique, secure URL that can be shared with the client. When the client opens the link, they see the auto-generated form specific to that request. No login or app download is required – just click the link and respond. The link is sufficiently complex/unguessable to ensure privacy, and it can optionally expire after a set time for security.
</Callout>

What I love most about this approach is that it meets clients where they are. No learning curve. No new accounts to create. The barrier to completion is as low as humanly possible.

And from a security standpoint, the links are designed to be unguessable. Each link contains a random UUID or hash that's virtually impossible to brute force. Optional link expiration and passcode protection add extra layers of security for sensitive materials.

### The Client Experience: Simple. Clear. Fast.

I obsessed over the client-side experience because, let's face it, if it's not dead simple, clients won't use it.

When your client clicks the link, they see:
1. A clean header with your request ("Please send me X, Y, and Z")
2. A simple form with clear labels and instructions
3. Upload buttons that work on desktop (drag-and-drop) and mobile (camera uploads)
4. A submit button

That's it. No distractions, no confusion, no friction.

<Callout title="From the Project Plan: Simple Upload Interface">
The recipient gets an easy-to-use interface to provide the files or information. The form clearly lists each requested item with an upload button or input field. The interface works on both desktop and mobile browsers, supporting drag-and-drop and camera uploads. There's no clutter – just a straightforward list of requested items and a way to submit them.
</Callout>

I've shown early prototypes to some non-technical friends and timed how long it takes them to figure out what to do. Most understand within seconds—always a good sign.

### Automated Reminders: The End of "Just Checking In" Emails

This feature alone would have saved me countless hours over the years. Instead of manually following up, the system handles reminders automatically:

1. You set a reminder schedule (e.g., 3 days after sending, then weekly)
2. If items remain unsubmitted, the system sends gentle reminders
3. The client gets a direct link back to their upload page
4. You get notified when they finally submit

<Callout title="From the Project Plan: Automated Reminders">
If the client hasn't uploaded the required files/information within a specified timeframe, the system will automatically send a polite reminder. Reminders can be via email or text (depending on what contact info was provided). For example, "Reminder: Please upload the signed contract and invoice for [Project Name]." The requester can set the reminder interval (e.g., 2 days, 1 week) when creating the request. Multiple reminders could be sent until completion, and a thank-you/confirmation message is sent once everything is received.
</Callout>

I'm particularly excited about this feature because it eliminates the most awkward part of client communication. Nobody likes sending or receiving nagging emails, yet they're necessary to keep projects moving. Automating this preserves the relationship while still getting results.

### Progress Tracking: Clear Visibility for Everyone

Both you and your client can see exactly what's been submitted and what's still outstanding:

- "Company Logo – ✅ Uploaded on 3/8"
- "Team Headshots – ❌ Not yet uploaded"
- "Project Brief – ✅ Completed on 3/9"

<Callout title="From the Project Plan: Progress Tracking">
The system tracks which items have been submitted and which are still outstanding. Both the requester and the recipient can see the status of each requested item (e.g., "Contract – ✅ Uploaded on 3/10" vs "Invoice – ❌ Not yet submitted"). The requester might have a dashboard or receive notifications showing completion status for each request link. Recipients, when visiting the link, can see if they have already provided some files and which ones remain.
</Callout>

This transparency eliminates confusion and provides subtle pressure to complete all requested items. I've found that simply showing progress bars or completion status can significantly improve follow-through rates.

## The Technical Side: How I'm Building It

For those interested in the nuts and bolts, here's how I'm putting this together. I'm keeping the tech stack modern but focused on performance and simplicity.

<Callout title="From the Project Plan: Tech Stack & Architecture">
Build the app using Next.js for the web frontend and serverless functions, running on the Bun runtime for speed and efficiency. Utilize Supabase for backend services – including a PostgreSQL database for storing request data and statuses, and Supabase Auth for user management (if required). For file storage, use an S3-compatible approach: for instance, Bun's S3 client can connect either to an AWS S3 bucket or to Supabase Storage (which offers an S3-like interface) to store uploaded files securely. The Next.js app (with Bun) will handle page rendering and API routes for creating requests, uploading files (or generating pre-signed URLs for direct upload), and triggering reminders.
</Callout>

Why this stack? A few reasons:

1. **Next.js** gives me the React-based frontend I love with built-in API routes and serverless functions
2. **Bun** provides ridiculous performance improvements over Node.js (important for file handling)
3. **Supabase** offers auth, database, and storage in one platform, reducing integration complexity

For the AI component, I'm currently using OpenAI's API, though I'm exploring local models for potential cost savings at scale.

### The Data Model: How It's Organized

Here's how I'm structuring the data:

<Callout title="From the Project Plan: Data Models & Storage">
Use Supabase/Postgres to store structured data:
- Requests table: stores each request with fields like requester_id (if logged in), request_text (the original natural language input), generated_form_schema (the fields expected), unique_link_id or token, creation date, due date (optional), etc.
- RequestItems table: stores each expected item (e.g., "signed contract" as one item, "invoice" as another) with attributes like type (file or text), status (pending/received), maybe a reference to the uploaded file location or text response.
- Submissions/Uploads table: stores actual submitted data – for file items, store file path or URL in S3; for text items, store the text provided.
- Reminders table or fields: store last reminder sent timestamp, or next reminder due, etc., or this could be computed.
- Users table: if using authentication for requesters.
- Ensure relationships (one Request to many RequestItems; one RequestItem may have one submission once completed).
- All file uploads will be stored in an S3 bucket (or Supabase Storage bucket) with a structured path (e.g., per request or per user directories) for organization.
</Callout>

This structure allows me to track the complete lifecycle of a request, from creation through reminder cycles to final submission.

### File Handling: Secure & Efficient

File uploads are the trickiest part of the system, requiring careful handling for security and performance:

<Callout title="From the Project Plan: File Upload Handling">
When a client uploads files through the shareable link, handle it either by direct upload to S3 via a pre-signed URL (for efficiency) or by having the Next.js API route (running on Bun) accept the file and then stream it to S3. Bun's S3 client can generate pre-signed upload URLs easily. Using pre-signed URLs means the front-end can upload directly to storage (reducing load on our server). After a successful upload, the backend records the file link and marks that item as completed. Ensure the upload interface can handle multiple files if the request item expects multiple (though in the current scope, each requested item is likely a single file or single piece of info). Also, set limits on file size or type if needed (and communicate those in the UI).
</Callout>

I'm leaning toward pre-signed URLs for direct S3 uploads to minimize server load and speed up the process. This approach allows the client's browser to upload directly to storage while maintaining security controls.

### Reminder System: The Follow-up Engine

The automated reminder system is a crucial component that prevents requests from being forgotten:

<Callout title="From the Project Plan: Automated Reminder System">
Implement a background job or scheduling mechanism to send reminders. Since Next.js and Supabase might not have a built-in scheduler out of the box, consider a few strategies:
- Use Supabase Edge Functions or a separate worker (could be a simple Bun script or cloud function) that runs periodically to check for overdue items. It can query the database for any RequestItems that are still pending past their due time (if a due date was set or using a default like 3 days) and send out reminder emails/texts.
- Alternatively, when a request is created, schedule a delayed job (e.g., using a task queue or simple cron job) to send a reminder after X time if not completed. This might require an external service or a small server process since Bun/Next might not keep state for scheduling long-term. Supabase could be leveraged by using PostgreSQL's built-in capabilities (like pg_cron or triggers) to schedule a notification.
- For sending emails, integrate with an email service (like SendGrid, Mailgun, or even Supabase's email if available). For SMS reminders, integrate with an SMS API such as Twilio if SMS functionality is desired. Ensure that contact info for reminders (email or phone) is captured either from the requester or embedded in the request link (e.g., the requester might input the client's email/phone when creating the request, or the client provides an email when uploading so we know where to remind).
</Callout>

I'm currently exploring a hybrid approach:
1. Using Supabase's built-in functionality where possible
2. Implementing a lightweight cron job for periodic checks
3. Integrating with SendGrid for email reminders (and potentially Twilio for SMS in the future)

### Security & Privacy: Protecting Sensitive Data

Since the tool will handle potentially sensitive documents, security is a top priority:

<Callout title="From the Project Plan: Security & Privacy">
Handle data with care since potentially sensitive documents will be uploaded.
- Secure Links: Each request link should contain a random token (e.g., UUID or hash) that is hard to guess. This way, only people with the link can access the request. Optionally, allow the requester to set a passcode for extra protection (the client would need to enter that passcode to upload, in case the link is accidentally shared).
- Storage Security: Store files in a private S3 bucket (or Supabase storage bucket) that is not publicly accessible. Access files via the backend or pre-signed URLs. Ensure that when a client uploads, they can only upload to the specific allowed path (to prevent any misuse). All data in the database and storage should be under proper access control rules (Supabase can enforce row-level security so one user cannot see another's requests, etc.). Encrypt sensitive data at rest if possible (Supabase encrypts data on their end; S3 can handle encryption at rest too).
- Data Retention: Consider how long to keep uploaded files. Possibly allow the requester to delete files or automatically purge them after a certain time (especially for free tier to save space, or for privacy). Make it clear in any privacy policy how data is handled. If working with international clients, consider compliance (GDPR: ability to delete data on request, etc.).
- Minimal PII Collection: The tool itself shouldn't need much personal data from the client aside from maybe their name or email if used for reminders. Keep the scope of personal data small (just what's needed for the request) to reduce privacy risk.
</Callout>

I'm implementing several layers of security:
1. Unguessable URLs with proper entropy
2. Optional passcode protection for sensitive requests
3. Encrypted storage at rest
4. Clear data retention policies
5. Minimal personal data collection
6. Proper access controls at every level

## Future Integrations & Extensions

While the core functionality is my immediate focus, I have plans for powerful integrations once the basics are solid:

<Callout title="From the Project Plan: Integrations with External Services">
Plan for optional integrations to enhance workflow:
- Cloud Storage (Google Drive/Dropbox): Allow the requester to choose to have uploaded files automatically copied to their Google Drive or Dropbox, or allow selecting files from those services when responding. This could be a premium feature. It involves using APIs from Drive/Dropbox to upload the received file to the user's account. Alternatively, integration might simply send the file to a specified folder. This saves the requester the step of downloading and re-uploading files to their storage.
- Communication Tools (Slack, Email): In addition to email/SMS reminders, integrate Slack or Teams so that notifications about uploads or request status can be sent to a channel. For example, when a client uploads a file, the tool could post a Slack message "Client X has uploaded the signed contract." This integration can help teams who live in Slack to stay updated. Also, possibly create requests directly from Slack via a bot command in the future (e.g., "/request contract and invoice from @client" generates a link and DM's it to the client).
- Productivity Tools: Consider a Chrome extension or email add-on for quickly generating request links while writing an email (e.g., highlight text "send me X" and click a button to generate a link to insert). This is a nice-to-have for later, once core product is stable.
</Callout>

I'm particularly excited about the Chrome extension idea. Imagine highlighting text in Gmail, right-clicking, and instantly generating a request link you can paste into your email. That's the kind of seamless workflow I'm aiming for.

## Scalability: Building for Growth

While I'm starting small, I'm designing the architecture to scale if this takes off:

<Callout title="From the Project Plan: Scalability">
Ensure the design can handle growing usage:
- Bun & Next.js Performance: Bun promises high performance – it should handle a good number of concurrent requests on modest hardware. Next.js could be deployed in a serverless environment or on a Bun-compatible server host. We should design stateless server functions (especially for file upload and form submission) so they can scale horizontally (multiple instances behind a load balancer or on Vercel/Netlify if they support Bun, or using Docker on a cloud service).
- Database Scaling: Supabase (Postgres) can scale vertically for quite a while and also has read replicas. If usage grows globally, consider caching frequently accessed data (like request info) or using Supabase's CDN for storage downloads. We might also implement pagination or limits on the dashboard if a user has many requests.
- File Storage Scaling: Using S3 or Supabase Storage means virtually unlimited scalability for files. We should plan for potential large volumes by organizing buckets/folders per user or per request to avoid performance issues listing too many files in one bucket path. Also, monitor storage costs as usage grows.
- Background Jobs: If using a separate process for reminders or any AI processing, ensure those can scale too (e.g., a queue system that can have multiple workers if needed).
- Global Access: If we anticipate international clients, deploying the service on edge networks (via Vercel Edge, Cloudflare, etc.) or using a CDN for static assets and uploads will help keep it snappy worldwide. This might be a later optimization.
</Callout>

The beauty of the chosen tech stack is that it's inherently scalable. Serverless functions allow horizontal scaling, S3 handles virtually unlimited storage, and Supabase/Postgres can grow with the user base.

## Business Model: How This Might Evolve

While I'm building this primarily to solve my own problem, I'm considering a sustainable business model if there's broader interest:

<Callout title="From the Project Plan: Monetization">
Freemium Model: Start with a free tier to encourage adoption, and offer premium plans for power users or teams. The free version could allow a limited number of active requests per month (for example, 5 open request links at a time) and basic features. This lets freelancers or small projects try it out at no cost. Premium tiers (monthly subscription) can unlock unlimited requests and advanced capabilities, ensuring those who heavily rely on the tool contribute to its upkeep.

Free Tier Features: The free plan should include the core functionality: AI form generation for requests, the shareable link, basic email reminders (maybe a fixed schedule like one reminder email), and storage for uploads up to a certain limit (e.g., each file up to X MB, and maybe Y GB total). No branding customization – the link and interface might show our product branding (which also markets the tool). The idea is a solo freelancer or small team can use it in a limited way and see the value.

Premium Tier Features: A paid subscription (or multiple tiers like Pro and Team) would include:
- Unlimited or Higher Volume: More active requests and higher storage limits (suitable for agencies handling many clients at once).
- Advanced Reminders: Custom reminder schedules, ability to send SMS reminders in addition to email, or even automatic escalation (e.g., CC another email after multiple missed reminders).
- Integrations: Access to integrations with Google Drive, Dropbox, Slack, etc., which might be reserved for paying users due to the added complexity and cost to maintain.
- Customization: Ability to use custom branding on the request page (e.g., add your logo or custom message), or use a custom domain for the links.
- Analytics & History: A log of all requests, when files were received, maybe insights like average turnaround time for each client (useful for agencies to report or improve processes).
- Priority Support: Faster support response, maybe even an onboarding session for teams.
- Possibly, AI usage beyond a limit could be a premium aspect if it's costly (e.g., free tier gets a certain number of AI form generations per month).
</Callout>

My current plan is to start with a generous free tier to validate the concept, then introduce premium features based on user feedback and usage patterns.

## Marketing & Branding: Speaking to the Pain

Having spent countless hours in client communication purgatory myself, I know exactly how to talk about this tool:

<Callout title="From the Project Plan: Marketing & Branding">
Target Audience & Pain Point: Aim the messaging at project managers, freelancers, and agency teams who are tired of chasing clients for files or information. The pain point is the endless email threads and delays in getting "that one damn file" they need to move forward. Acknowledge this frustration in marketing: e.g., "We know the hardest part of your job can be simply getting clients to send you what you asked for." By relating to this common pain, we grab attention with empathy and a promise of relief.

Value Proposition: Emphasize how the tool saves time and hassle. Key message: stop chasing, start receiving. Stress that with a simple link, clients will deliver what you need without the usual friction. It's like having an automated assistant that handles the follow-up for you. Also highlight the uniqueness: AI-generated request forms (so you don't even spend time setting up forms) and automatic reminders (so you never have to send nagging emails). The outcome is a smoother project workflow and happier client relationships.

Tone and Voice: Use a mix of playful and professional tone. We want to come across as a helpful, slightly cheeky friend who helps you get rid of a frustration. For example, it's okay to use a light humorous touch like "the one damn thing" in a tagline (it's edgy but relatable), balanced with professionalism in explaining features. The overall voice should instill confidence that this is a reliable tool, but not be overly formal. We solve a serious workflow problem, but we can have fun doing it. Think along the lines of Slack's or Trello's marketing tone – friendly, human, and to the point.

Tagline Ideas:
- "Get the One Damn Thing You Need—Without the Hassle." – conveys frustration and relief in one go (grabs attention with the candid tone).
- "Stop Chasing Clients. Just Send a Link." – straight to the point; explains the core solution (no more chasing, the link does the work).
- "AI-Generated Forms for Instant Requests. No Setup, No Friction." – highlights the innovative AI aspect and the ease (instant, no friction).
</Callout>

I'm personally drawn to "Stop Chasing Clients. Just Send a Link." It captures the essence of the tool without being overly clever. But I'd love feedback on which resonates most with you!

## My Development Process & Timeline

I'm building this in the open, with iterative releases planned:

1. **Alpha (Now)**: Core functionality with minimal UI polish
2. **Beta (April 2025)**: Refined experience, basic reminders, early adopter testing
3. **Public Launch (May 2025)**: Full feature set, polished UI, open to everyone

I'm currently focused on getting the core request-and-upload flow working flawlessly before adding bells and whistles.

## Why I'm Sharing All This

I know this post is unusually detailed for a side project announcement. But I believe in building in public and sharing the full journey—not just the polished end result.

This approach has several benefits:
1. It forces me to think through all aspects of the project thoroughly
2. It invites feedback from potential users early in the process
3. It might inspire others working on similar problems
4. It creates a comprehensive reference I can revisit as development continues

If you've read this far, you're exactly the kind of person I'd love to have as an early tester or collaborator.

## How You Can Get Involved

If PleaseSendMeThis.com sounds like something that would make your life easier, here's how you can participate:

1. **Join the Beta**: Sign up at [pleasesendmethis.com](http://pleasesendmethis.com) for early access
2. **Contribute**: If you're a developer familiar with Next.js, Bun, or Supabase, I'd welcome collaboration
3. **Share Feedback**: Tell me about your file request pain points or feature wishlist
4. **Spread the Word**: If you know others who might benefit, please share this post

## Final Thoughts: The Tool I Wish I Had Years Ago

Every time I chase a client for files, I think about how much better this process could be. We've made incredible advancements in technology, yet somehow, the simple act of requesting and receiving files remains needlessly complicated.

PleaseSendMeThis.com is my attempt to solve this problem once and for all—not with more complexity, but with radical simplicity.

Type a request. Share a link. Get what you need. Move on with your life.

That's the promise, and I'm committed to delivering it.

<Note>
  If you want to follow along with the development or contribute to the project, you can find the GitHub repository at [github.com/samanat/pleasesendmethis](http://github.com/samanat/pleasesendmethis) or reach out to me directly.
</Note>